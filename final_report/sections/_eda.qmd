---
title: "_eda"
format: html
server: shiny
---
# Exploratory Data Analysis

```{r}
library(tidyverse)
library(plotly)
library(shiny)
library(knitr)
library(caret)
library(vcd)
```
```{r}
# Load the preprocessed dataset
preprocessed_stroke_tb <- read.csv("../../data/datasets/preprocessed_stroke_tb.csv")
encoded_stroke_tb <- read.csv("../../data/datasets/encoded_stroke_tb.csv")
outlier_stroke_tb <- read.csv("../../data/datasets/outlier_stroke_tb.csv")
balanced_stroke_tb <- read.csv("../../data/datasets/balanced_stroke_tb.csv")


```

## Descriptive Statistics

We start our EDA with a summary of the numerical and categorical variables in our dataset. The summary includes the count, mean, standard deviation, minimum, 1st quartile, median, 3rd quartile, and maximum values for numerical variables.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Generate summary of selected numerical variables
summary_table <- summary(preprocessed_stroke_tb[, c("age", "avg_glucose_level", "bmi")])

# Convert the summary to a data frame & display it with kable
summary_table <- as.data.frame.matrix(summary_table)
knitr::kable(summary_table, caption = "Summary of numerical Variables", row.names = FALSE)
```

For the categorical variables, we present the total number and proportion of each category’s occurrences. We combined all categorical variables into one table for a better overview.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# List of categorical variables
variables_to_summarize <- c("stroke", "gender", "ever_married", "work_type", "Residence_type", "smoking_status", "hypertension", "heart_disease")

# Convert binary integer variables to factors
preprocessed_stroke_tb <- preprocessed_stroke_tb %>%
  mutate(
    stroke = as.factor(stroke),
    hypertension = as.factor(hypertension),
    heart_disease = as.factor(heart_disease)
  )

# Calculate total count for proportion calculation
total_count <- nrow(preprocessed_stroke_tb)

# Create summary table 
summary_table <- bind_rows(
  lapply(variables_to_summarize, function(var) {
    preprocessed_stroke_tb %>%
      group_by(.data[[var]]) %>%
      summarize(
        Count = n(),
        Proportion = n() / total_count,
        .groups = "drop"
      ) %>%
      rename(Type = .data[[var]]) %>%
      mutate(
        Variable = var,
        Type = as.character(Type),
        Proportion = round(Proportion * 100, 2)  
      )
  })
) %>%
  select(Variable, Type, Count, Proportion) %>%  
  arrange(Variable, Type)                        

# Display the combined table with kable
knitr::kable(summary_table, caption = "Summary of Categorical Variables with Proportion", row.names = FALSE)
```

## Univariate Analysis

#### Numerical variables

First, we visualized all numerical variables in a histogram grouped by stroke occurrence to get an overview of the distribution of the data and their relationship with the target variable.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Histogram of numerical variables grouped by stroke variable
# Define the UI
ui <- fluidPage(
  titlePanel("Numerical variables grouped by stroke variable"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting variable
      selectInput("variable", "Select Variable:", 
                  choices = c("Age" = "age", "Average Glucose Level" = "avg_glucose_level", "BMI" = "bmi")),
      
      # Conditional panel to show the bin width slider only if "Show Standardized Data" is unchecked
      conditionalPanel(
        condition = "input.standardize == false",
        sliderInput("binwidth", "Bin Width:", min = 1, max = 10, value = 5)
      ),
      
      # Checkbox for standardized data
      checkboxInput("standardize", "Show Standardized Data", value = FALSE)
    ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic
server <- function(input, output, session) {
  
  observe({
    # Change bin width to 1 if standardized data is checked
    if (input$standardize) {
      updateSliderInput(session, "binwidth", value = 1)
    } else {
      updateSliderInput(session, "binwidth", value = 5)
    }
  })
  
  output$histogramPlot <- renderPlotly({
    # Retrieve the selected variable and stroke data
    original_data <- encoded_stroke_tb[[input$variable]]
    stroke_data <- encoded_stroke_tb$stroke
    
    # Calculate mean and standard deviation for original data
    mean_val <- mean(original_data)
    sd_val <- sd(original_data)
    
    # Standardize the data if checkbox is selected
    if (input$standardize) {
      data <- scale(original_data)
      x_label <- paste("Standardized", input$variable)
      # Mean and SD lines at 0 and ±1 for standardized data
      mean_line <- 0
      sd_lines <- c(-1, 1)
    } else {
      data <- original_data
      x_label <- input$variable
      # Use calculated mean and SD for original data
      mean_line <- mean_val
      sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
    }
    
    # Combine data and stroke status into a data frame
    plot_data <- data.frame(data = data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))
    
    # Generate the ggplot stacked histogram with mean and SD lines
    p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
      geom_histogram(binwidth = input$binwidth, color = "white", position = "stack") +
      labs(title = paste("Distribution of", x_label), x = x_label, y = "Frequency", fill = "Stroke Status") +
      geom_vline(aes(xintercept = mean_line), color = "blue", linetype = "dashed", linewidth = 1) +
      geom_vline(aes(xintercept = sd_lines[1]), color = "red", linetype = "dotted", linewidth = 0.8) +
      geom_vline(aes(xintercept = sd_lines[2]), color = "red", linetype = "dotted", linewidth = 0.8)
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Based on the summary table for numerical variables and the histogram, we can observe the following descriptive characteristics:

-   `age`: The dataset includes individuals with ages ranging from 0.08 to 82 years, with an average age of 43.23 years but a peak around 57 years, a second peak around 78 years, and a standard deviation of 22.61 years.
-   `avg_glucose_level`: We can observe a right-skewed bimodal distribution with a mean of 106.15 and a standard deviation of 45.28. The average glucose levels range from 55.12 to 271.74 mg/dL.
-   `bmi`: The histogram shows a right-skewed distribution with a mean of 28.86 and a standard deviation of 7.85. The BMI values range from 10.3 to 97.6.

For completeness we added a violin Plot of the numerical variables with correlation coefficients respective to `stroke` displayed below the plot.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Define numerical variables (adjust if there are more)
numerical_variables <- c("age", "avg_glucose_level", "bmi")

# Shiny app with separate display of the correlation coefficient
shinyApp(
  ui = fluidPage(
    selectInput("selected_variable", "Choose a Variable:", choices = numerical_variables),
    plotlyOutput("violin_plot"),
    htmlOutput("correlation_text")  # Separate output for the correlation coefficient
  ),
  server = function(input, output) {
    
    output$violin_plot <- renderPlotly({
      selected_variable <- input$selected_variable
      
      # Generate the violin plot
      plot <- plot_ly(outlier_stroke_tb, x = ~factor(stroke), y = ~as.numeric(outlier_stroke_tb[[selected_variable]]), type = "violin",
                      box = list(visible = TRUE),
                      meanline = list(visible = TRUE)) %>%
        layout(
          title = paste("Violin Plot of", selected_variable, "by Stroke"),
          xaxis = list(title = "Stroke"),
          yaxis = list(title = selected_variable)
        )
      
      plot  # Display the plot
    })
    
    # Render the correlation text below the plot
    output$correlation_text <- renderUI({
      selected_variable <- input$selected_variable
      correlation <- cor(as.numeric(outlier_stroke_tb[[selected_variable]]), as.numeric(outlier_stroke_tb$stroke), method = "pearson")
      HTML(paste("Correlation Coefficient with Stroke:", round(correlation, 2)))
    })
  }
)
```

The histogram and violin charts have been grouped by stroke occurrence. This allows us to observe the distribution of the data for each variable in relation to the target variable `stroke`. Based on the charts, `age` and `avg_glucose_level` exhibit notable differences in the proportions of stroke cases across their value ranges. Stroke cases are more frequent at higher glucose levels and in the age range of 60 to 80 years. The variable `age` shows a weak positive relationship with the target variable `stroke` (correlation coefficient of 0.25). `avg_glucose_level` shows an even weaker positive relationship with the target variable (correlation coefficient of 0.13). In contrast, `bmi` and `stroke` show no relationship with a correlation coefficient of 0.04.

#### Categorical variables

The second part of our EDA examines the distribution of the categorical variables and their relationship with the target variable in a stacked bar chart:

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Barchart of categorical variables grouped by stroke variable

# Define the UI
ui <- fluidPage(
  titlePanel("Categorical Variables Grouped by Stroke Variable"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting the variable for the X-axis
      selectInput("x_variable", "Select Variable for X-Axis:",
                  choices = c("Gender" = "gender", 
                              "Ever Married" = "ever_married",
                              "Work Type" = "work_type", 
                              "Residence Type" = "Residence_type", 
                              "Smoking Status" = "smoking_status",
                              "Hypertension" = "hypertension", 
                              "Heart Disease" = "heart_disease"))
    ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  
  output$histogramPlot <- renderPlotly({
    
    # Create a reactive data frame that filters "Other" for gender
    filtered_data <- preprocessed_stroke_tb
    if (input$x_variable == "gender") {
      filtered_data <- filtered_data %>% filter(gender != "Other")
    }
    
    # Check if selected variable is Hypertension or Heart Disease
    if (input$x_variable %in% c("hypertension", "heart_disease")) {
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio") +
        scale_x_continuous(breaks = c(0, 1), labels = c("No", "Yes"))  # Custom x-axis for binary variables
    } else {
      # For other categorical variables
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio")
    }
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Relevant differences in the proportions of stroke cases can be observed across the levels of the following categorical variables:

-   `smoking_status`: The proportion of stroke cases is highest among individuals who formerly smoked, compared to those who never smoked or currently smoke. This relationship could be influenced by age, as individuals who formerly smoked may be older on average. Current smokers show a slightly higher proportion of stroke cases than those who never smoked.
-   `hypertension`: Individuals with hypertension have a higher proportion of stroke cases compared to those without hypertension.
-   `ever_married`: Married individuals show a higher proportion of stroke cases compared to those who have never been married. This relationship might be influenced by age, as younger individuals are less likely to be married, and the risk of stroke typically increases with age.
-   `work_type`: The proportion of stroke cases varies across work types, with private sector employees and self-employed individuals exhibiting higher proportions of stroke cases than individuals in other work categories.
-   `heart disease`: Individuals with heart disease have a higher proportion of stroke cases compared to those without heart disease.

In contrast, the following variables appear to be not relevant, as there are no differences in the proportions of stroke cases across their levels:

-   `gender`

-   `Residence_type`

Based on the univariate analysis, `heart_disease`, `smoking_status`, `hypertension`, `ever_married`, and `work_type` could be potential candidates for further exploration and modeling among the categorical variables. These variables exhibit notable differences in the proportions of stroke cases across their levels, suggesting they may be important predictors of stroke risk. Among the numerical variables, `age` and `avg_glucose_level` show a weak to very weak positive relationship with the target variable `stroke`, suggesting they may also be important predictors of stroke risk.

## Bivariate Analysis

In the bivariate analysis we examined correlations between our features. We used a correlation matrix to visualize the relationships between the numerical variables and the target variable `stroke`.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Select the numeric columns from your data
numeric_data <- preprocessed_stroke_tb[, c("age", "avg_glucose_level", "bmi")]

# Calculate the correlation matrix
correlation_matrix <- cor(numeric_data, use = "complete.obs")

# Convert the correlation matrix to a format that plotly can use (optional step)
heatmap_data <- as.data.frame(as.table(correlation_matrix))

# Plot the correlation matrix as a heatmap using plotly
plot_ly(
  x = colnames(correlation_matrix),
  y = rownames(correlation_matrix),
  z = correlation_matrix,
  type = "heatmap",
  colorscale = "Viridis"  # Corrected typo
) %>%
  layout(
    title = "Correlation Matrix Heatmap",
    xaxis = list(title = "", tickangle = 45),
    yaxis = list(title = "")
  )
```

Our numerical features don't seem to be strongly correlated with each other. The strongest correlation is observed between `age` and `bmi` (0.324), which is not surprising, as BMI is often used as a measure of body fat and is known to increase with age. The correlation between the other numerical features is rather low. We can therefore safely assume independence of our numerical features

To examine associations and multicollinearity between the categorical variables, we use a chi-squared test. The chi-squared test is a statistical test used to determine whether there is a significant association between two categorical variables. To determine the importance of the test result we additionally computed the Cramér's V for effect size (threshold applied here 0.3). First we removed all outliers and for security, we apply the Fisher's Exact Test if there are zero counts in the contingency table.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
cat_variables = c("hypertension", 
                  "heart_disease", "ever_married", "work_type", "Residence_type", "smoking_status", "gender")

preprocessed_stroke_tb <- preprocessed_stroke_tb %>%
  filter(!(gender == 'Other' & work_type == 'Never_worked'))

for (index1 in 1:(length(cat_variables) - 1)) {
  var1 <- cat_variables[index1]
  
  for (index2 in (index1 + 1):length(cat_variables)) {
    var2 <- cat_variables[index2]
    
    contingency_table <- table(preprocessed_stroke_tb[[var1]], preprocessed_stroke_tb[[var2]])
    
    # Run Fisher's Exact Test if there are zero counts, otherwise Chi-square Test
    if (any(contingency_table == 0)) {
      chi_square_result <- fisher.test(contingency_table, simulate.p.value = TRUE)
    } else {
      chi_square_result <- chisq.test(contingency_table)
    }
    
    cramers_v <- assocstats(contingency_table)$cramer
    
    if (cramers_v > 0.3 && chi_square_result$p.value < 0.05) {
      cat("Relationship between", var1, "and", var2, "\n")
      cat("P-value:", chi_square_result$p.value, "\n")
      cat("Cramér's V:", cramers_v, "\n")
      print(contingency_table)
      cat("\n")
    }
  }
}

```
The only relationship, which seems to be problematic in terms of multicollinearity seems to be between `ever_married` and `work_type`. For the prediction model, we will therefore exclude one of the two features. Another possibility is to further explore their relationship with the VIF(Variation Inflation Factor), which will help us with the decision to either keep both variables or drop one of them.

As all other effect sizes appear to be smaller than 0.3, we can safely conclude that all other categorical features are sufficiently independent to use as predictors. In conclusion, multicollinearity does not appear to be present among the variables, and we can therefore proceed. We refrain from conducting a multivariate analysis, as the results from this section seem robust enough to also conclude no multicollinearity among multiple features.

## Balanced Dataset Analysis

### Proportions of the Target Variable (Stroke)
We would like to compare the original dataset with the balanced dataset.
First, we expect plots showing the distribution of the target variable to appear more balanced in the oversampled datase compared to the original dataset.

```{r}
# Bar chart for the original dataset (preprocessed_stroke_tb)
# Load necessary library
library(ggplot2)

# Bar chart for the original dataset
ggplot(preprocessed_stroke_tb, aes(x = factor(stroke))) +
  geom_bar() +
  labs(title = "Stroke Distribution in Original Dataset",
       x = "Stroke (0 = No Stroke, 1 = Stroke)",
       y = "Count") +
  theme_minimal()

```

```{r}
# Balanced dataset
# Bar chart for the balanced dataset
ggplot(balanced_stroke_tb, aes(x = factor(stroke))) +
  geom_bar() +
  labs(title = "Stroke Distribution in Balanced Dataset",
       x = "Stroke (0 = No Stroke, 1 = Stroke)",
       y = "Count") +
  theme_minimal()
```

Indeed, the distribution of the target variable `stroke` appears  balanced in the oversampled dataset compared to the original dataset. This is a positive outcome, as a balanced dataset can help improve the performance of machine learning models by reducing bias towards the majority class.However, lets check how the predictor variables have been affected by the oversampling.

### Descriptive Statistics for the balanced dataset

```{r}
#| code-fold: true
#| code-summary: "Click to show code"
# Generate summary of selected numerical variables
summary_table <- summary(balanced_stroke_tb[, c("age", "avg_glucose_level", "bmi")])

# Convert the summary to a data frame & display it with kable
summary_table <- as.data.frame.matrix(summary_table)
knitr::kable(summary_table, caption = "Summary of numerical Variables", row.names = FALSE)
```

`age` and `avg_glucose_level` have very different summary statistics. The median age in the balanced dataset increased by 14 years to 59 years, up from 45 years in the original dataset. The average glucose level is 93,51 mg/dL, with only s slight increase from 91,89 mg/dL.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Histogram of numerical variables grouped by stroke variable
# Define the UI
ui <- fluidPage(
  titlePanel("Numerical variables grouped by stroke variable"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting variable
      selectInput("variable", "Select Variable:", 
                  choices = c("Age" = "age", "Average Glucose Level" = "avg_glucose_level")),
      
      # Conditional panel to show the bin width slider only if "Show Standardized Data" is unchecked
      conditionalPanel(
        condition = "input.standardize == false",
        sliderInput("binwidth", "Bin Width:", min = 1, max = 10, value = 5)
      ),
      
      # Checkbox for standardized data
      checkboxInput("standardize", "Show Standardized Data", value = FALSE)
    ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic
server <- function(input, output, session) {
  
  observe({
    # Change bin width to 1 if standardized data is checked
    if (input$standardize) {
      updateSliderInput(session, "binwidth", value = 1)
    } else {
      updateSliderInput(session, "binwidth", value = 5)
    }
  })
  
  output$histogramPlot <- renderPlotly({
    # Retrieve the selected variable and stroke data
    original_data <- balanced_stroke_tb[[input$variable]]
    stroke_data <- balanced_stroke_tb$stroke
    
    # Calculate mean and standard deviation for original data
    mean_val <- mean(original_data)
    sd_val <- sd(original_data)
    
    # Standardize the data if checkbox is selected
    if (input$standardize) {
      data <- scale(original_data)
      x_label <- paste("Standardized", input$variable)
      # Mean and SD lines at 0 and ±1 for standardized data
      mean_line <- 0
      sd_lines <- c(-1, 1)
    } else {
      data <- original_data
      x_label <- input$variable
      # Use calculated mean and SD for original data
      mean_line <- mean_val
      sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
    }
    
    # Combine data and stroke status into a data frame
    plot_data <- data.frame(data = data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))
    
    # Generate the ggplot stacked histogram with mean and SD lines
    p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
      geom_histogram(binwidth = input$binwidth, color = "white", position = "stack") +
      labs(title = paste("Distribution of", x_label), x = x_label, y = "Frequency", fill = "Stroke Status") +
      geom_vline(aes(xintercept = mean_line), color = "blue", linetype = "dashed", linewidth = 1) +
      geom_vline(aes(xintercept = sd_lines[1]), color = "red", linetype = "dotted", linewidth = 0.8) +
      geom_vline(aes(xintercept = sd_lines[2]), color = "red", linetype = "dotted", linewidth = 0.8)
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

Now incorporating the balanced dataset, the univariate analysis of categorical variables such as `heart_disease`, `smoking_status`, `hypertension`, `ever_married`, and `work_type` will be re-examined to observe differences. These variables previously showed notable disparities in the proportions of stroke cases across their levels in the original dataset, indicating their potential as predictors of stroke risk. Visualizing these variables with the balanced dataset will help identify any shifts in patterns and strengthen their relevance for further exploration and modeling.

#### Note to myself: use upsampled dataset on preprocessed instead of encoded dataset. errors in smoking status and work type when using balanced_stroke_tb
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Barchart of categorical variables grouped by stroke variable

# Define the UI
ui <- fluidPage(
  titlePanel("Categorical Variables Grouped by Stroke Variable"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting the variable for the X-axis
      selectInput("x_variable", "Select Variable for X-Axis:",
                  choices = c("Ever Married" = "ever_married",
                              "Work Type" = "work_type", 
                              "Smoking Status" = "smoking_status",
                              "Hypertension" = "hypertension", 
                              "Heart Disease" = "heart_disease"))
    ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  
  output$histogramPlot <- renderPlotly({
    
    # Create a reactive data frame that filters "Other" for gender
    filtered_data <- balanced_stroke_tb
    if (input$x_variable == "gender") {
      filtered_data <- filtered_data %>% filter(gender != "Other")
    }
    
    # Check if selected variable is Hypertension or Heart Disease
    if (input$x_variable %in% c("hypertension", "heart_disease")) {
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio") +
        scale_x_continuous(breaks = c(0, 1), labels = c("No", "Yes"))  # Custom x-axis for binary variables
    } else {
      # For other categorical variables
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio")
    }
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

## Stratified Dataset Analysis

In our previous EDA we observed that `age` is the strongest predictor for `stroke`. To ensure that our model is not biased towards the age distribution in the dataset, we will perform stratified sampling based on the age variable. We will create two age groups (one group composed of individuals below 60, the other one composed of individuals of 60 and over) and ensure that the distribution of these groups is similar in both the training and test datasets. With this sampling method, we hope to increase our model's generalizability and robustness in the section.

```{r}
#| code-fold: true
#| code-summary: "Click to show code"



# Create age groups
stratified_stroke_tb <- encoded_stroke_tb %>%
  mutate(age_class = case_when(
    age < 60 ~ "under_60",
    age >= 60 ~ "60_and_over"
  ))
head(stratified_stroke_tb)

save.csv(stratified_stroke_tb, "../../data/datasets/stratified_stroke_tb.csv")
```

# Stratified sampling
```{r}
#| code-fold: true
#| code-summary: "Click to show code"
set.seed(42)
trainIndex <- createDataPartition(data$stroke, p = 0.8, list = FALSE, times = 1)
trainData <- data[trainIndex, ]
testData <- data[-trainIndex, ]
```


### Stratified Sampling

## EDA for Stratified Dataset
We perform an Exploratory Data Analysis on two distinct age groups: individuals under 60 years old and those of 60 years old and over. This analysis aims to uncover valuable insights regarding stroke occurrences, risk factors, and demographic characteristics within each group.

To begin our analysis, we focus first on the group of individuals under 60 years old. 

## Descriptive Statistics for under_60 

```{r, message=FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Filter the dataset for individuals under 60 years old using the age_group column
under_60_group <- stratified_stroke_tb %>%
  filter(age_class == "under_60")

# Generate summary of selected numerical variables for the under 60 group
summary_table_under_60 <- summary(under_60_group[, c("age", "avg_glucose_level", "bmi")])
summary_table_under_60

# Convert the summary to a data frame & display it with kable
summary_table_under_60 <- as.data.frame.matrix(summary_table_under_60)
knitr::kable(summary_table_under_60, caption = "Summary of Numerical Variables for Individuals Under 60 Years Old", row.names = FALSE)

```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# List of categorical variables
variables_to_summarize <- c("stroke", "gender", "ever_married", "work_type_children", "work_type_Govt_job", "work_type_Never_worked", "work_type_Private","work_type_Self.employed", "smoking_status_formerly.smoked", "smoking_status_never.smoked", "smoking_status_smokes", "Residence_type", "hypertension", "heart_disease")

# Convert binary integer variables to factors for the stratified dataset
stratified_stroke_tb <- stratified_stroke_tb %>%
  mutate(
    stroke = as.factor(stroke),
    hypertension = as.factor(hypertension),
    heart_disease = as.factor(heart_disease)
  )

# Filter the dataset for individuals under 60 years old using the age_class column
under_60_group <- stratified_stroke_tb %>%
  filter(age_class == "under_60")

# Calculate total count for proportion calculation
total_count_under_60 <- nrow(under_60_group)

# Create summary table for individuals under 60
summary_table_under_60 <- bind_rows(
  lapply(variables_to_summarize, function(var) {
    under_60_group %>%
      group_by(.data[[var]]) %>%
      summarize(
        Count = n(),
        Proportion = n() / total_count_under_60,
        .groups = "drop"
      ) %>%
      rename(Type = .data[[var]]) %>%
      mutate(
        Variable = var,
        Type = as.character(Type),
        Proportion = round(Proportion * 100, 2)  
      )
  })
) %>%
  select(Variable, Type, Count, Proportion) %>%  
  arrange(Variable, Type)                        

# Display the combined table with kable
knitr::kable(summary_table_under_60, caption = "Summary of Categorical Variables for Individuals Under 60 Years Old with Proportions", row.names = FALSE)
```

## Univariate Analysis for under_60

### Numerical variables for under_60

Same as for the whole group EDA, we visualized all numerical variables in a histogram grouped by stroke occurrence to get an overview of the distribution of the data and their relationship with the target variable.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Histogram of numerical variables grouped by stroke variable for individuals under 60

# Define the UI
ui <- fluidPage(
  titlePanel("Numerical Variables Grouped by Stroke Variable for Individuals Under 60"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting variable
      selectInput("variable", "Select Variable:", 
                  choices = c("Age" = "age", "Average Glucose Level" = "avg_glucose_level", "BMI" = "bmi")),
      
      # Conditional panel to show the bin width slider only if "Show Standardized Data" is unchecked
      conditionalPanel(
        condition = "input.standardize == false",
        sliderInput("binwidth", "Bin Width:", min = 1, max = 10, value = 5)
      ),
      
      # Checkbox for standardized data
      checkboxInput("standardize", "Show Standardized Data", value = FALSE)
    ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic
server <- function(input, output, session) {
  
  observe({
    # Change bin width to 1 if standardized data is checked
    if (input$standardize) {
      updateSliderInput(session, "binwidth", value = 1)
    } else {
      updateSliderInput(session, "binwidth", value = 5)
    }
  })
  
  output$histogramPlot <- renderPlotly({
    # Filter the data to only include individuals under 60
    under_60_data <- stratified_stroke_tb[which(stratified_stroke_tb$age_class == "under_60"), ]
    
    # Retrieve the selected variable and stroke data
    original_data <- under_60_data[[input$variable]]
    stroke_data <- under_60_data$stroke
    
    # Calculate mean and standard deviation for original data
    mean_val <- mean(original_data, na.rm = TRUE)
    sd_val <- sd(original_data, na.rm = TRUE)
    
    # Standardize the data if checkbox is selected
    if (input$standardize) {
      data <- scale(original_data)
      x_label <- paste("Standardized", input$variable)
      # Mean and SD lines at 0 and ±1 for standardized data
      mean_line <- 0
      sd_lines <- c(-1, 1)
    } else {
      data <- original_data
      x_label <- input$variable
      # Use calculated mean and SD for original data
      mean_line <- mean_val
      sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
    }
    
    # Combine data and stroke status into a data frame
    plot_data <- data.frame(data = data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))
    
    # Generate the ggplot stacked histogram with mean and SD lines
    p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
      geom_histogram(binwidth = input$binwidth, color = "white", position = "stack") +
      labs(title = paste("Distribution of", x_label), x = x_label, y = "Frequency", fill = "Stroke Status") +
      geom_vline(aes(xintercept = mean_line), color = "blue", linetype = "dashed", linewidth = 1) +
      geom_vline(aes(xintercept = sd_lines[1]), color = "red", linetype = "dotted", linewidth = 0.8) +
      geom_vline(aes(xintercept = sd_lines[2]), color = "red", linetype = "dotted", linewidth = 0.8)
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Violin plot of numerical variables grouped by stroke variable for individuals under 60

# Define numerical variables (adjust if there are more)
numerical_variables <- c("age", "avg_glucose_level", "bmi")

# Shiny app with separate display of the correlation coefficient
shinyApp(
  ui = fluidPage(
    titlePanel("Violin Plot for Individuals Under 60"),
    selectInput("selected_variable", "Choose a Variable:", choices = numerical_variables),
    plotlyOutput("violin_plot"),
    htmlOutput("correlation_text")  # Separate output for the correlation coefficient
  ),
  server = function(input, output) {
    
    output$violin_plot <- renderPlotly({
      selected_variable <- input$selected_variable
      
      # Filter the data to include only individuals under 60
      under_60_data <- stratified_stroke_tb[which(stratified_stroke_tb$age_class == "under_60"), ]
      
      # Generate the violin plot
      plot <- plot_ly(under_60_data, x = ~factor(stroke), y = ~as.numeric(under_60_data[[selected_variable]]), type = "violin",
                      box = list(visible = TRUE),
                      meanline = list(visible = TRUE)) %>%
        layout(
          title = paste("Violin Plot of", selected_variable, "by Stroke"),
          xaxis = list(title = "Stroke"),
          yaxis = list(title = selected_variable)
        )
      
      plot  # Display the plot
    })
    
    # Render the correlation text below the plot
    output$correlation_text <- renderUI({
      selected_variable <- input$selected_variable
      
      # Filter the data to include only individuals under 60
      under_60_data <- stratified_stroke_tb[which(stratified_stroke_tb$age_class == "under_60"), ]
      
      # Calculate the correlation coefficient
      correlation <- cor(as.numeric(under_60_data[[selected_variable]]), as.numeric(under_60_data$stroke), method = "pearson")
      HTML(paste("Correlation Coefficient with Stroke:", round(correlation, 2)))
    })
  }
)
# Run the application
shinyApp(ui = ui, server = server)
```

Based on the summary table for numerical variables and the histogram, we can observe the following descriptive characteristics:

-   `age`: The dataset includes individuals with ages ranging from 0.08 to 59 years, with an average age of 33.03 years but a peak around ### years, a second peak around ### years, and a standard deviation of ### years.
-   `avg_glucose_level`: We can observe a right-skewed bimodal distribution with a mean of 100.34 and a standard deviation of ###. The average glucose levels range from 55.12 to 267.76 mg/dL.
-   `bmi`: The histogram shows a right-skewed distribution with a mean of 28.5 and a standard deviation of ###. The BMI values range from 10.3 to 97.6.

For completeness we added a violin Plot of the numerical variables with correlation coefficients respective to `stroke` displayed below the plot.

### Categorical variables for under_60 
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Barchart of categorical variables grouped by stroke variable for individuals under 60

# Define the UI
ui <- fluidPage(
  titlePanel("Categorical Variables Grouped by Stroke Variable for Individuals Under 60"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting the variable for the X-axis
      selectInput("x_variable", "Select Variable for X-Axis:",
                  choices = c("Gender" = "gender", 
                              "Ever Married" = "ever_married", "Work Type is Children" = "work_type_children", "Work Type is Government Job" = "work_type_Govt_job", "Work Type is Never Worked" = "work_type_Never_worked", "Work Type is Private" = "work_type_Private", "Work Type is Self-employed" = "work_type_Self.employed", "Smoking status is Formerly smoked"= "smoking_status_formerly.smoked", "Smoking status is Never smoked"="smoking_status_never.smoked", "Smoking status is Smokes"="smoking_status_smokes", "Residence Type" = "Residence_type", "Hypertension" = "hypertension", "Heart Disease" = "heart_disease"))
       ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  
  output$histogramPlot <- renderPlotly({
    # Filter the dataset to include only individuals under 60
    under_60_data <- stratified_stroke_tb[which(stratified_stroke_tb$age_class == "under_60"), ]
    
    # Create a reactive data frame that filters "Other" for gender
    filtered_data <- under_60_data
    if (input$x_variable == "gender") {
      filtered_data <- filtered_data %>% filter(gender != "Other")
    }
    
    # Check if selected variable is Hypertension or Heart Disease
    if (input$x_variable %in% c("hypertension", "heart_disease")) {
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio") +
        scale_x_continuous(breaks = c(0, 1), labels = c("No", "Yes"))  # Custom x-axis for binary variables
    } else {
      # For other categorical variables
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio")
    }
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

### Bivariate Analysis for under_60

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Filter the data for individuals under 60 using the stratified_stroke_df dataset
under_60_data <- stratified_stroke_tb[stratified_stroke_tb$age_class == "under_60", ]

# Select the numeric columns from the under_60_data
numeric_data <- under_60_data[, c("age", "avg_glucose_level", "bmi")]

# Calculate the correlation matrix
correlation_matrix <- cor(numeric_data, use = "complete.obs")

# Plot the correlation matrix as a heatmap using plotly
plot_ly(
  x = colnames(correlation_matrix),
  y = rownames(correlation_matrix),
  z = correlation_matrix,
  type = "heatmap",
  colorscale = "Viridis"
) %>%
  layout(
    title = "Correlation Matrix Heatmap for Individuals Under 60",
    xaxis = list(title = "", tickangle = 45),
    yaxis = list(title = "")
  )
```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

cat_variables = c("hypertension", 
                  "heart_disease", "ever_married", "work_type_children", "work_type_Govt_job", "work_type_Private","work_type_Self.employed", "smoking_status_formerly.smoked", "smoking_status_never.smoked", "smoking_status_smokes", "Residence_type", "gender")

# Filter data for individuals under 60 and remove outliers
under_60_data <- stratified_stroke_tb %>%
  filter(age_class == "under_60") %>%
  select(-work_type_Never_worked) 

# Perform Chi-squared tests for the specified categorical variables
for (index1 in 1:(length(cat_variables) - 1)) {
  var1 <- cat_variables[index1]
  
  for (index2 in (index1 + 1):length(cat_variables)) {
    var2 <- cat_variables[index2]
    
    contingency_table <- table(under_60_data[[var1]], under_60_data[[var2]])
    
    # Run Fisher's Exact Test if there are zero counts, otherwise Chi-square Test
    if (any(contingency_table == 0)) {
      chi_square_result <- fisher.test(contingency_table, simulate.p.value = TRUE)
    } else {
      chi_square_result <- chisq.test(contingency_table)
    }
    
    cramers_v <- assocstats(contingency_table)$cramer
    
    if (cramers_v > 0.3 && chi_square_result$p.value < 0.05) {
      cat("Relationship between", var1, "and", var2, "\n")
      cat("P-value:", chi_square_result$p.value, "\n")
      cat("Cramér's V:", cramers_v, "\n")
      print(contingency_table)
      cat("\n")
    }
  }
}
```

Now that we completed the EDA of the group aged below 60, let's check for the group aged of 60 and over.

## Descriptive Statistics for 60_and_over

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Filter the dataset for individuals 60 and over using the age_class column
over_60_group <- stratified_stroke_tb %>%
  filter(age_class == "60_and_over")

# Generate summary of selected numerical variables for the 60 and over group
summary_table_over_60 <- summary(over_60_group[, c("age", "avg_glucose_level", "bmi")])
summary_table_over_60

# Convert the summary to a data frame & display it with kable
summary_table_over_60 <- as.data.frame.matrix(summary_table_over_60)
knitr::kable(summary_table_over_60, caption = "Summary of Numerical Variables for Individuals 60 and Over Years Old", row.names = FALSE)
```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# List of categorical variables
variables_to_summarize <- c("stroke", "gender", "ever_married", "work_type_children", 
                             "work_type_Govt_job", "work_type_Private", 
                             "work_type_Self.employed", "smoking_status_formerly.smoked", 
                             "smoking_status_never.smoked", 
                             "smoking_status_smokes", "Residence_type", 
                             "hypertension", "heart_disease")

# Convert binary integer variables to factors for the stratified dataset if not already done
stratified_stroke_tb <- stratified_stroke_tb %>%
  mutate(
    stroke = as.factor(stroke),
    hypertension = as.factor(hypertension),
    heart_disease = as.factor(heart_disease)
  )

# Filter the dataset for individuals 60 and over using the age_class column
over_60_group <- stratified_stroke_tb %>%
  filter(age_class == "60_and_over")

# Calculate total count for proportion calculation
total_count_over_60 <- nrow(over_60_group)

# Create summary table for individuals 60 and over
summary_table_over_60 <- bind_rows(
  lapply(variables_to_summarize, function(var) {
    over_60_group %>%
      group_by(.data[[var]]) %>%
      summarize(
        Count = n(),
        Proportion = n() / total_count_over_60,
        .groups = "drop"
      ) %>%
      rename(Type = .data[[var]]) %>%
      mutate(
        Variable = var,
        Type = as.character(Type),
        Proportion = round(Proportion * 100, 2)
      )
  })
) %>%
  select(Variable, Type, Count, Proportion) %>%  
  arrange(Variable, Type)

# Display the combined table with kable
knitr::kable(summary_table_over_60, caption = "Summary of Categorical Variables for Individuals 60 and Over Years Old with Proportions", row.names = FALSE)
```
## Univariate Analysis for 60_and_over

### Numerical variables for 60_and_over
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Histogram of numerical variables grouped by stroke variable for individuals 60 and over

# Define the UI for the histogram
ui_histogram <- fluidPage(
  titlePanel("Numerical Variables Grouped by Stroke Variable for Individuals 60 and Over"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting variable
      selectInput("variable", "Select Variable:", 
                  choices = c("Age" = "age", "Average Glucose Level" = "avg_glucose_level", "BMI" = "bmi")),
      
      # Conditional panel to show the bin width slider only if "Show Standardized Data" is unchecked
      conditionalPanel(
        condition = "input.standardize == false",
        sliderInput("binwidth", "Bin Width:", min = 1, max = 10, value = 5)
      ),
      
      # Checkbox for standardized data
      checkboxInput("standardize", "Show Standardized Data", value = FALSE)
    ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic for the histogram
server_histogram <- function(input, output, session) {
  
  observe({
    # Change bin width to 1 if standardized data is checked
    if (input$standardize) {
      updateSliderInput(session, "binwidth", value = 1)
    } else {
      updateSliderInput(session, "binwidth", value = 5)
    }
  })
  
  output$histogramPlot <- renderPlotly({
    # Filter the data to include only individuals 60 and over
    over_60_data <- stratified_stroke_tb[which(stratified_stroke_tb$age_class == "60_and_over"), ]
    
    # Retrieve the selected variable and stroke data
    original_data <- over_60_data[[input$variable]]
    stroke_data <- over_60_data$stroke
    
    # Calculate mean and standard deviation for original data
    mean_val <- mean(original_data, na.rm = TRUE)
    sd_val <- sd(original_data, na.rm = TRUE)
    
    # Standardize the data if checkbox is selected
    if (input$standardize) {
      data <- scale(original_data)
      x_label <- paste("Standardized", input$variable)
      # Mean and SD lines at 0 and ±1 for standardized data
      mean_line <- 0
      sd_lines <- c(-1, 1)
    } else {
      data <- original_data
      x_label <- input$variable
      # Use calculated mean and SD for original data
      mean_line <- mean_val
      sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
    }
    
    # Combine data and stroke status into a data frame
    plot_data <- data.frame(data = data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))
    
    # Generate the ggplot stacked histogram with mean and SD lines
    p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
      geom_histogram(binwidth = input$binwidth, color = "white", position = "stack") +
      labs(title = paste("Distribution of", x_label), x = x_label, y = "Frequency", fill = "Stroke Status") +
      geom_vline(aes(xintercept = mean_line), color = "blue", linetype = "dashed", linewidth = 1) +
      geom_vline(aes(xintercept = sd_lines[1]), color = "red", linetype = "dotted", linewidth = 0.8) +
      geom_vline(aes(xintercept = sd_lines[2]), color = "red", linetype = "dotted", linewidth = 0.8)
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Run the histogram application
shinyApp(ui = ui_histogram, server = server_histogram)
```

### Categorical variables for 60_and_over

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Barchart of categorical variables grouped by stroke variable for individuals 60 and over

# Define the UI
ui <- fluidPage(
  titlePanel("Categorical Variables Grouped by Stroke Variable for Individuals 60 and Over"),
  sidebarLayout(
    sidebarPanel(
      # Dropdown for selecting the variable for the X-axis
      selectInput("x_variable", "Select Variable for X-Axis:",
                  choices = c("Gender" = "gender", 
                              "Ever Married" = "ever_married", 
                              "Work Type is Children" = "work_type_children", 
                              "Work Type is Government Job" = "work_type_Govt_job", 
                              "Work Type is Private" = "work_type_Private", 
                              "Work Type is Self-employed" = "work_type_Self.employed", 
                              "Smoking Status is Formerly Smoked" = "smoking_status_formerly.smoked", 
                              "Smoking Status is Never Smoked" = "smoking_status_never.smoked", 
                              "Smoking Status is Smokes" = "smoking_status_smokes", 
                              "Residence Type" = "Residence_type", 
                              "Hypertension" = "hypertension", 
                              "Heart Disease" = "heart_disease"))
      ),
    mainPanel(
      # Display the interactive plotly histogram
      plotlyOutput("histogramPlot")
    )
  )
)

# Define the server logic
server <- function(input, output) {
  
  output$histogramPlot <- renderPlotly({
    # Filter the dataset to include only individuals 60 and over
    over_60_data <- stratified_stroke_tb[which(stratified_stroke_tb$age_class == "60_and_over"), ]
    
    # Create a reactive data frame that filters "Other" for gender
    filtered_data <- over_60_data
    if (input$x_variable == "gender") {
      filtered_data <- filtered_data %>% filter(gender != "Other")
    }
    
    # Check if selected variable is Hypertension or Heart Disease
    if (input$x_variable %in% c("hypertension", "heart_disease")) {
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio") +
        scale_x_continuous(breaks = c(0, 1), labels = c("No", "Yes"))  # Custom x-axis for binary variables
    } else {
      # For other categorical variables
      p <- ggplot(filtered_data, aes_string(x = input$x_variable, fill = "as.factor(stroke)")) +
        geom_bar(position = "fill") +
        labs(fill = "STROKE", y = "Ratio")
    }
    
    # Convert ggplot to an interactive plotly object
    ggplotly(p)
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

### Bivariate Analysis for 60_and_over

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Filter the data for individuals 60 and over using the stratified_stroke_tb dataset
over_60_data <- stratified_stroke_tb[stratified_stroke_tb$age_class == "60_and_over", ]

# Select the numeric columns from the over_60_data
numeric_data <- over_60_data[, c("age", "avg_glucose_level", "bmi")]

# Calculate the correlation matrix
correlation_matrix <- cor(numeric_data, use = "complete.obs")

# Plot the correlation matrix as a heatmap using plotly
plot_ly(
  x = colnames(correlation_matrix),
  y = rownames(correlation_matrix),
  z = correlation_matrix,
  type = "heatmap",
  colorscale = "Viridis"
) %>%
  layout(
    title = "Correlation Matrix Heatmap for Individuals 60 and Over",
    xaxis = list(title = "", tickangle = 45),
    yaxis = list(title = "")
  )
```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

cat_variables = c("hypertension", 
                  "heart_disease", "ever_married", "work_type_children", "work_type_Govt_job", 
                  "work_type_Private","work_type_Self.employed", "smoking_status_formerly.smoked", 
                  "smoking_status_never.smoked", "smoking_status_smokes", "Residence_type", "gender")

# Filter data for individuals 60 and over and remove outliers
over_60_data <- stratified_stroke_tb %>%
  filter(age_class == "60_and_over") %>%
  select(-work_type_Never_worked)  # If you have already removed it

# Perform Chi-squared tests for the specified categorical variables
for (index1 in 1:(length(cat_variables) - 1)) {
  var1 <- cat_variables[index1]
  
  for (index2 in (index1 + 1):length(cat_variables)) {
    var2 <- cat_variables[index2]
    
    contingency_table <- table(over_60_data[[var1]], over_60_data[[var2]])
    
    # Run Fisher's Exact Test if there are zero counts, otherwise Chi-square Test
    if (any(contingency_table == 0)) {
      chi_square_result <- fisher.test(contingency_table, simulate.p.value = TRUE)
    } else {
      chi_square_result <- chisq.test(contingency_table)
    }
    
    cramers_v <- assocstats(contingency_table)$cramer
        if (cramers_v > 0.3 && chi_square_result$p.value < 0.05) {
      cat("Relationship between", var1, "and", var2, "\n")
      cat("P-value:", chi_square_result$p.value, "\n")
      cat("Cramér's V:", cramers_v, "\n")
      print(contingency_table)
      cat("\n")
    
    }
  }
}
```

## Balancing Stratified Dataset

In our dataset, we have a total of 1,376 individuals aged 60 and over, and 3,734 individuals under 60.
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
count_over_60 <- nrow(stratified_stroke_tb[stratified_stroke_tb$age_class == "60_and_over", ])
count_over_60
count_under_60 <- nrow(stratified_stroke_tb[stratified_stroke_tb$age_class == "under_60", ])
count_under_60
```

Given this disparity in sample sizes, it is essential to balance the dataset for several reason. Balancing the dataset is crucial because it prevents biased results and misleading conclusions stemming from the unequal representation of age groups. An imbalanced dataset can skew predictive models toward the majority class, hindering their ability to generalize effectively, especially for individuals aged 60 and over. Moreover, it allows for clearer comparisons of outcomes across age groups and minimizes the risk of overfitting. Ultimately, a balanced dataset leads to more reliable insights and easier interpretation of results.


```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"


# Count of individuals in each age group
count_under_60 <- nrow(stratified_stroke_tb[stratified_stroke_tb$age_class == "under_60", ])
count_60_and_over <- nrow(stratified_stroke_tb[stratified_stroke_tb$age_class == "60_and_over", ])

# Over-sampling the 60_and_over group to match the size of under_60
set.seed(42)  # For reproducibility
balanced_over_sampled <- stratified_stroke_tb %>%
  filter(age_class == "60_and_over") %>%
  sample_n(size = count_under_60, replace = TRUE) %>%
  bind_rows(stratified_stroke_tb %>% filter(age_class == "under_60"))

save.csv(balanced_over_sampled, "../../data/datasets/balanced_over_sampled.csv")
```


