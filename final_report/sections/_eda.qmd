---
title: "_eda"
format: html
---
# Exploratory Data Analysis

```{r, warning=FALSE}
library(tidyverse)
library(plotly)
library(knitr)
library(caret)
library(vcd)
```
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
outlier_stroke_tb <- 
  read.csv("../../data/datasets/outlier_stroke_tb.csv")
balanced_stroke_tb <-
  read.csv("../../data/datasets/balanced_stroke_tb.csv")
preprocessed_stroke_tb <-
  read.csv("../../data/datasets/preprocessed_stroke_tb.csv")
```

## Descriptive Statistics

We start our EDA with a summary of the numerical and categorical variables in our dataset. The summary includes the count, mean, standard deviation, minimum, 1st quartile, median, 3rd quartile, and maximum values for numerical variables.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Generate summary of selected numerical variables
summary_table <- summary(outlier_stroke_tb[, c("age", "avg_glucose_level", "bmi")])

# Convert the summary to a data frame & display it with kable
summary_table <- as.data.frame.matrix(summary_table)
knitr::kable(summary_table, caption = "Summary of numerical Variables", row.names = FALSE)
```

For the categorical variables, we present the total number and proportion of each categoryâ€™s occurrences. We combined all categorical variables into one table for a better overview.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# List of categorical variables
variables_to_summarize <- c("stroke", "gender", "ever_married", "work_type", "Residence_type", "smoking_status", "hypertension", "heart_disease")

# Convert binary integer variables to factors
outlier_stroke_tb <- outlier_stroke_tb %>%
  mutate(
    stroke = as.factor(stroke),
    hypertension = as.factor(hypertension),
    heart_disease = as.factor(heart_disease)
  )

# Calculate total count for proportion calculation
total_count <- nrow(outlier_stroke_tb)

# Create summary table 
summary_table <- bind_rows(
  lapply(variables_to_summarize, function(var) {
    outlier_stroke_tb %>%
      group_by(.data[[var]]) %>%
      summarize(
        Count = n(),
        Proportion = n() / total_count,
        .groups = "drop"
      ) %>%
      rename(Type = .data[[var]]) %>%
      mutate(
        Variable = var,
        Type = as.character(Type),
        Proportion = round(Proportion * 100, 2)  
      )
  })
) %>%
  select(Variable, Type, Count, Proportion) %>%  
  arrange(Variable, Type)                        

# Display the combined table with kable
knitr::kable(summary_table, caption = "Summary of Categorical Variables with Proportion", row.names = FALSE)
```

## Univariate Analysis

### Numerical variables

First, we visualized all numerical variables in a histogram grouped by stroke occurrence to get an overview of the distribution of the data and their relationship with the target variable.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

library(ggplot2)
library(plotly)

# Function to create the histogram
create_histogram <- function(data, variable, stroke_variable, binwidth = 5, show_legend = FALSE) {
  # Extract the variable and stroke data
  original_data <- data[[variable]]
  stroke_data <- data[[stroke_variable]]
  
  # Calculate mean and standard deviation for reference lines
  mean_val <- mean(original_data, na.rm = TRUE)
  sd_val <- sd(original_data, na.rm = TRUE)
  mean_line <- mean_val
  sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
  
  # Combine data and stroke status into a data frame
  plot_data <- data.frame(data = original_data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))
  
  # Generate the ggplot stacked histogram with mean and SD lines
  p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
    geom_histogram(binwidth = binwidth, color = "white", position = "stack") +
    labs(title = paste("Distribution of", variable), x = variable, y = "Frequency", fill = "Stroke Status") +
    geom_vline(xintercept = mean_line, color = "blue", linetype = "dashed", linewidth = 1) +
    geom_vline(xintercept = sd_lines[1], color = "red", linetype = "dotted", linewidth = 0.8) +
    geom_vline(xintercept = sd_lines[2], color = "red", linetype = "dotted", linewidth = 0.8) +
    theme_minimal()
  
  # Convert to interactive Plotly plot
  ggplotly(p) %>%
    layout(showlegend = show_legend) # Control legend visibility
}

# Generate histograms for each variable separately
hist_age <- create_histogram(outlier_stroke_tb, "age", "stroke", binwidth = 5, show_legend = TRUE)
hist_glucose <- create_histogram(outlier_stroke_tb, "avg_glucose_level", "stroke", binwidth = 5, show_legend = FALSE)
hist_bmi <- create_histogram(outlier_stroke_tb, "bmi", "stroke", binwidth = 5, show_legend = FALSE)

# Display each histogram separately
print(hist_age)
print(hist_glucose)
print(hist_bmi)
```
Based on the summary table for numerical variables and the histogram, we can observe the following descriptive characteristics:

-   `age`: The dataset includes individuals with ages ranging from 0.08 to 82 years, with an average age of 43.23 years but a peak around 57 years, a second peak around 78 years, and a standard deviation of 22.61 years.
-   `avg_glucose_level`: We can observe a right-skewed bimodal distribution with a mean of 106.15 and a standard deviation of 45.28. The average glucose levels range from 55.12 to 271.74 mg/dL.
-   `bmi`: The histogram shows a right-skewed distribution with a mean of 28.86 and a standard deviation of 7.85. The BMI values range from 10.3 to 97.6.

For completeness we added a violin Plot of the numerical variables with correlation coefficients respective to `stroke` displayed below the plot.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

# Function to create a violin plot
create_violin_plot <- function(data, variable, stroke_variable) {
  # Ensure the stroke variable is a factor
  data[[stroke_variable]] <- as.factor(data[[stroke_variable]])
  
  # Generate the violin plot with a name for the trace
  plot <- plot_ly(data, x = ~get(stroke_variable), y = ~get(variable), type = "violin",
                  box = list(visible = TRUE),
                  meanline = list(visible = TRUE),
                  name = variable) %>%  # Add this line to set the name
    layout(
      title = paste("Violin Plot of", variable, "by Stroke"),
      xaxis = list(title = "Stroke"),
      yaxis = list(title = variable)
    )
  
  plot
}

# Generate individual plots
plot_age <- create_violin_plot(outlier_stroke_tb, variable = "age", stroke_variable = "stroke")
plot_glucose <- create_violin_plot(outlier_stroke_tb, variable = "avg_glucose_level", stroke_variable = "stroke")
plot_bmi <- create_violin_plot(outlier_stroke_tb, variable = "bmi", stroke_variable = "stroke")

# Combine plots into a grid layout (1 row, 3 columns)
combined_plot <- subplot(
  plot_age, plot_glucose, plot_bmi,
  nrows = 1, titleX = TRUE, titleY = TRUE
) %>%
  layout(title = "Violin Plots of Numerical Variables by Stroke")

# Display the combined plot
combined_plot
```
The histogram and violin charts have been grouped by stroke occurrence. This allows us to observe the distribution of the data for each variable in relation to the target variable `stroke`. Based on the charts, `age` and `avg_glucose_level` exhibit notable differences in the proportions of stroke cases across their value ranges. Stroke cases are more frequent at higher glucose levels and in the age range of 60 to 80 years. The variable `age` shows a weak positive relationship with the target variable `stroke` (correlation coefficient of 0.24). `avg_glucose_level` shows an even weaker positive relationship with the target variable (correlation coefficient of 0.13). In contrast, `bmi` and `stroke` show no relationship with a correlation coefficient of 0.04.
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(knitr)

# Convert columns to numeric if they are not already
outlier_stroke_tb$age <- as.numeric(as.character(outlier_stroke_tb$age))
outlier_stroke_tb$avg_glucose_level <- as.numeric(as.character(outlier_stroke_tb$avg_glucose_level))
outlier_stroke_tb$bmi <- as.numeric(as.character(outlier_stroke_tb$bmi))
outlier_stroke_tb$stroke <- as.numeric(as.character(outlier_stroke_tb$stroke))

# Calculate the correlation coefficients
correlation_matrix <- cor(outlier_stroke_tb[, c("age", "avg_glucose_level", "bmi", "stroke")], use = "complete.obs")

# Create a kable table
kable(correlation_matrix, digits = 2, caption = "Correlation Coefficients between Variables")
```


### Categorical variables

The second part of our EDA examines the distribution of the categorical variables and their relationship with the target variable in a stacked bar chart:

```{r, message=FALSE}
#| code-fold: true
#| code-summary: "Click to show code"


library(ggplot2)
library(plotly)
library(dplyr)

# Define choices for the variable selection, excluding Gender and Residence Type
x_variable_choices <- c("Ever Married" = "ever_married",
                        "Work Type" = "work_type", 
                        "Smoking Status" = "smoking_status",
                        "Hypertension" = "hypertension", 
                        "Heart Disease" = "heart_disease")

# Create a filtered data frame based on all selected variables
filtered_data <- outlier_stroke_tb
# Remove "Other" for the gender variable
filtered_data <- filtered_data %>% filter(!(gender == "Other"))  # Simply check for 'Other' in gender

# Initialize an empty list to store plots
plots <- list()

# Loop through each categorical variable and create a bar chart
for (selected_variable in x_variable_choices) {
  
  # Get variable name
  variable_name <- names(x_variable_choices)[which(x_variable_choices == selected_variable)]
  
  if (variable_name %in% c("hypertension", "heart_disease")) {
    p <- ggplot(filtered_data, aes_string(x = selected_variable, fill = "as.factor(stroke)")) +
      geom_bar(position = "fill") +
      labs(title = paste("Distribution of", variable_name),
           fill = "STROKE", y = "Ratio") +
      scale_x_continuous(breaks = c(0, 1), labels = c("No", "Yes"))  # Custom x-axis for binary variables
  } else {
    # For other categorical variables
    p <- ggplot(filtered_data, aes_string(x = selected_variable, fill = "as.factor(stroke)")) +
      geom_bar(position = "fill") +
      labs(title = paste("Distribution of", variable_name),
           fill = "STROKE", y = "Ratio")
  }
  
  # Convert ggplot to an interactive plotly object and store it in the list
  plots[[variable_name]] <- ggplotly(p)
}

# Display all plots
for (plot in plots) {
  print(plot)  # You can use print to display each plot one after the other
}

```

Relevant differences in the proportions of stroke cases can be observed across the levels of the following categorical variables:

-   `smoking_status`: The proportion of stroke cases is highest among individuals who formerly smoked, compared to those who never smoked or currently smoke. This relationship could be influenced by age, as individuals who formerly smoked may be older on average. Current smokers show a slightly higher proportion of stroke cases than those who never smoked.
-   `hypertension`: Individuals with hypertension have a higher proportion of stroke cases compared to those without hypertension.
-   `ever_married`: Married individuals show a higher proportion of stroke cases compared to those who have never been married. This relationship might be influenced by age, as younger individuals are less likely to be married, and the risk of stroke typically increases with age.
-   `work_type`: The proportion of stroke cases varies across work types, with private sector employees and self-employed individuals exhibiting higher proportions of stroke cases than individuals in other work categories.
-   `heart disease`: Individuals with heart disease have a higher proportion of stroke cases compared to those without heart disease.

In contrast, the following variables appear to be not relevant, as there are no differences in the proportions of stroke cases across their levels (see Appendix):

-   `gender`

-   `Residence_type`

Based on the univariate analysis, `heart_disease`, `smoking_status`, `hypertension`, `ever_married`, and `work_type` could be potential candidates for further exploration and modeling among the categorical variables. These variables exhibit notable differences in the proportions of stroke cases across their levels, suggesting they may be important predictors of stroke risk. Among the numerical variables, `age` and `avg_glucose_level` show a weak to very weak positive relationship with the target variable `stroke`, suggesting they may also be important predictors of stroke risk. These predictors may even become more relevant when examined in a balanced dataset, which our initial hypotheses would suggest. 

## Bivariate Analysis

In the bivariate analysis we examined correlations between our features. We used a correlation matrix to visualize the relationships between the numerical variables and the target variable `stroke`.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Select the numeric columns from your data
numeric_data <- outlier_stroke_tb[, c("age", "avg_glucose_level", "bmi")]

# Calculate the correlation matrix
correlation_matrix <- cor(numeric_data, use = "complete.obs")

# Convert the correlation matrix to a format that plotly can use (optional step)
heatmap_data <- as.data.frame(as.table(correlation_matrix))

# Plot the correlation matrix as a heatmap using plotly
plot_ly(
  x = colnames(correlation_matrix),
  y = rownames(correlation_matrix),
  z = correlation_matrix,
  type = "heatmap",
  colorscale = "Viridis"  # Corrected typo
) %>%
  layout(
    title = "Correlation Matrix Heatmap",
    xaxis = list(title = "", tickangle = 45),
    yaxis = list(title = "")
  )
```

Our numerical features don't seem to be strongly correlated with each other. The strongest correlation is observed between `age` and `bmi` (0.324), which is not surprising, as BMI is often used as a measure of body fat and is known to increase with age. The correlation between the other numerical features is rather low. We can therefore safely assume independence of our numerical features



## Balanced Dataset Analysis

### Proportions of the Target Variable (Stroke)
We would like to compare the original dataset with the balanced dataset.
First, we expect plots showing the distribution of the target variable to appear more balanced in the oversampled datase compared to the original dataset.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Bar chart for the original dataset (outlier_stroke_tb)
# Load necessary libraries
library(ggplot2)
library(plotly)

# Bar chart for the original dataset
p <- ggplot(outlier_stroke_tb, aes(x = factor(stroke))) +
  geom_bar() +
  labs(title = "Stroke Distribution in Original Dataset",
       x = "Stroke (0 = No Stroke, 1 = Stroke)",
       y = "Count") +
  theme_minimal()

# Convert ggplot to an interactive plotly object
ggplotly(p)
```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
# Balanced dataset
# Load necessary libraries
library(ggplot2)
library(plotly)

# Bar chart for the balanced dataset
p <- ggplot(balanced_stroke_tb, aes(x = factor(stroke))) +
  geom_bar() +
  labs(title = "Stroke Distribution in Balanced Dataset",
       x = "Stroke (0 = No Stroke, 1 = Stroke)",
       y = "Count") +
  theme_minimal()

# Convert ggplot to an interactive plotly object
ggplotly(p)
```

Indeed, the distribution of the target variable `stroke` appears  balanced in the oversampled dataset compared to the original dataset. This is a positive outcome, as a balanced dataset can help improve the performance of machine learning models by reducing bias towards the majority class.However, lets check how the predictor variables have been affected by the oversampling.

### Descriptive Statistics for the balanced dataset

```{r}
#| code-fold: true
#| code-summary: "Click to show code"
# Generate summary of selected numerical variables
summary_table <- summary(balanced_stroke_tb[, c("age", "avg_glucose_level", "bmi")])

# Convert the summary to a data frame & display it with kable
summary_table <- as.data.frame.matrix(summary_table)
knitr::kable(summary_table, caption = "Summary of numerical Variables", row.names = FALSE)
```

`age` and `avg_glucose_level` have very different summary statistics. The median age in the balanced dataset increased by 14 years to 59 years, up from 45 years in the original dataset. The median average glucose level is 96,84 mg/dL, with only slight increase from 91,89 mg/dL. The median bmi stays the same as the original dataset. 

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(ggplot2)
library(plotly)

# Define choices for the variable selection
variable_choices <- c("Age" = "age", "Average Glucose Level" = "avg_glucose_level")

# Initialize an empty list to store plots
plots <- list()

# Loop through each variable and create a histogram
for (selected_variable in variable_choices) {
  
  # Retrieve the current selected variable and stroke data
  original_data <- balanced_stroke_tb[[selected_variable]]
  stroke_data <- balanced_stroke_tb$stroke
  
  # Calculate mean and standard deviation
  mean_val <- mean(original_data, na.rm = TRUE)  # Handle NA values
  sd_val <- sd(original_data, na.rm = TRUE)      # Handle NA values

  # Standardization logic (modify if you want to standardize some histograms)
  standardize <- FALSE  # Change to TRUE if standardized data is needed
  binwidth <- 5  # Set a default bin width

  # Standardize the data if needed
  if (standardize) {
    data <- scale(original_data)
    x_label <- paste("Standardized", selected_variable)
    mean_line <- 0
    sd_lines <- c(-1, 1)
  } else {
    data <- original_data
    x_label <- selected_variable
    mean_line <- mean_val
    sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
  }

  # Combine data and stroke status into a data frame
  plot_data <- data.frame(data = data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))

  # Generate the ggplot stacked histogram with mean and SD lines
  p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
    geom_histogram(binwidth = binwidth, color = "white", position = "stack") +
    labs(title = paste("Distribution of", x_label), x = x_label, y = "Frequency", fill = "Stroke Status") +
    geom_vline(aes(xintercept = mean_line), color = "blue", linetype = "dashed", linewidth = 1) +
    geom_vline(aes(xintercept = sd_lines[1]), color = "red", linetype = "dotted", linewidth = 0.8) +
    geom_vline(aes(xintercept = sd_lines[2]), color = "red", linetype = "dotted", linewidth = 0.8)

  # Convert ggplot to an interactive plotly object and store it in the list
  plots[[selected_variable]] <- ggplotly(p)
}

# Display all plots
for (plot in plots) {
  print(plot)  # Print each plot one after the other
}
```

Now incorporating the balanced dataset, the univariate analysis of categorical variables such as `heart_disease`, `smoking_status`, `hypertension`, `ever_married`, and `work_type` will be re-examined to observe differences. These variables previously showed notable disparities in the proportions of stroke cases across their levels in the original dataset, indicating their potential as predictors of stroke risk. Visualizing these variables with the balanced dataset will help identify any shifts in patterns and strengthen their relevance for further exploration and modeling.

#### Note to myself: use upsampled dataset on preprocessed instead of encoded dataset. errors in smoking status and work type when using balanced_stroke_tb
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

library(ggplot2)
library(plotly)
library(dplyr)

# Define the choices for the x-axis variables
x_variable_choices <- c("Ever Married" = "ever_married",
                         "Work Type" = "work_type", 
                         "Smoking Status" = "smoking_status",
                         "Hypertension" = "hypertension", 
                         "Heart Disease" = "heart_disease")

# Initialize an empty list to store plots
plots <- list()

# Create a filtered data frame based on the initial data
filtered_data <- balanced_stroke_tb

# Loop through each variable to create a bar chart
for (selected_variable in x_variable_choices) {
  
  # Check if selected variable is gender and filter accordingly (assuming you also have gender in your dataset)
  if (selected_variable == "gender") {
    filtered_data <- filtered_data %>% filter(gender != "Other")
  }
  
  # Generate the bar chart based on the selected variable
  if (selected_variable %in% c("hypertension", "heart_disease")) {
    p <- ggplot(filtered_data, aes_string(x = selected_variable, fill = "as.factor(stroke)")) +
      geom_bar(position = "fill") +
      labs(title = paste("Distribution of", selected_variable), 
           fill = "STROKE", y = "Ratio") +
      scale_x_continuous(breaks = c(0, 1), labels = c("No", "Yes"))  # Custom x-axis for binary variables
  } else {
    # For other categorical variables
    p <- ggplot(filtered_data, aes_string(x = selected_variable, fill = "as.factor(stroke)")) +
      geom_bar(position = "fill") +
      labs(title = paste("Distribution of", selected_variable), 
           fill = "STROKE", y = "Ratio")
  }
  
  # Convert ggplot to an interactive plotly object and store it in the list
  plots[[selected_variable]] <- ggplotly(p)
}

# Display all plots
for (plot in plots) {
  print(plot)  # Print each plot one after the other
}
```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"

library(ggplot2)
library(plotly)
library(dplyr)

# Define the choices for the x-axis variables
x_variable_choices <- c("Ever Married" = "ever_married",
                         "Work Type" = "work_type", 
                         "Smoking Status" = "smoking_status",
                         "Hypertension" = "hypertension", 
                         "Heart Disease" = "heart_disease")

# Initialize an empty list to store plots
plots <- list()

# Create a filtered data frame based on the initial data
filtered_data <- balanced_stroke_tb

# Loop through each variable to create a bar chart
for (selected_variable in x_variable_choices) {
  
  # Check if selected variable is gender and filter accordingly (assuming you also have gender in your dataset)
  if (selected_variable == "gender") {
    filtered_data <- filtered_data %>% filter(gender != "Other")
  }
  
  # Generate the bar chart based on the selected variable
  if (selected_variable %in% c("hypertension", "heart_disease")) {
    p <- ggplot(filtered_data, aes_string(x = selected_variable, fill = "as.factor(stroke)")) +
      geom_bar(position = "fill") +
      labs(title = paste("Distribution of", selected_variable), 
           fill = "STROKE", y = "Ratio") +
      scale_x_continuous(breaks = c(0, 1), labels = c("No", "Yes"))  # Custom x-axis for binary variables
  } else {
    # For other categorical variables
    p <- ggplot(filtered_data, aes_string(x = selected_variable, fill = "as.factor(stroke)")) +
      geom_bar(position = "fill") +
      labs(title = paste("Distribution of", selected_variable), 
           fill = "STROKE", y = "Ratio")
  }
  
  # Convert ggplot to an interactive plotly object and store it in the list
  plots[[selected_variable]] <- ggplotly(p)
}

# Display all plots
for (plot in plots) {
  print(plot)  # Print each plot one after the other
}
```


```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(plotly)

# Define numerical variables
numerical_variables <- c("age", "avg_glucose_level", "bmi")

# Choose a variable (you can replace this with a specific variable)
selected_variable <- numerical_variables[1]  # Modify as needed

# Generate the violin plot
plot <- plot_ly(outlier_stroke_tb, x = ~factor(stroke), y = ~as.numeric(balanced_stroke_tb[[selected_variable]]), type = "violin",
                 box = list(visible = TRUE),
                 meanline = list(visible = TRUE)) %>%
  layout(
    title = paste("Violin Plot of", selected_variable, "by Stroke"),
    xaxis = list(title = "Stroke"),
    yaxis = list(title = selected_variable)
  )

# Display the plot
plot

# Calculate and display the correlation coefficient
correlation <- cor(as.numeric(outlier_stroke_tb[[selected_variable]]), as.numeric(outlier_stroke_tb$stroke), method = "pearson")
cat(sprintf("Correlation Coefficient with Stroke: %.2f\n", correlation))
```

# Stratified Dataset Analysis

In our previous EDA we observed that `age` is the strongest predictor for `stroke`. To ensure that our model is not biased towards the age distribution in the dataset, we will perform stratified sampling based on the age variable. We will create two age groups (one group composed of individuals below 60, the other one composed of individuals of 60 and over) and ensure that the distribution of these groups is similar in both the training and test datasets. 

Looking at the violin plot for individuals that have experienced a stroke, the average age  is 67.73 years. We have arbitrarily chosen to divide the dataset into two age groups at age 60 for several reasons. This age threshold may clinically be significant because we know that the risk of stroke increases notably after a certain age, allowing us to focus our analysis more effectively on the populations most affected. Additionally, individuals over 60 may exhibit different biological changes that impact stroke risk factors.

##### Add proof that 60 is a great choice from the internet #####

With this sampling method, we hope to increase our model's generalizability and robustness in the section.

```{r}
#| code-fold: true
#| code-summary: "Click to show code"

# Create dataset for individuals under 60 years old
under_60_data <- outlier_stroke_tb[outlier_stroke_tb$age < 60, ]

# Create dataset for individuals aged 60 years and older
over_60_data <- outlier_stroke_tb[outlier_stroke_tb$age >= 60, ]

# Display the first few rows of each dataset 
head(under_60_data)
head(over_60_data)
```

## EDA for Stratified Dataset
We perform an Exploratory Data Analysis on two distinct age groups: individuals under 60 years old and those of 60 years old and over. This analysis aims to uncover valuable insights regarding stroke occurrences, risk factors, and demographic characteristics within each group.

To begin our analysis, we focus first on the group of individuals under 60 years old. 

### Descriptive Statistics for individuals below 60 

```{r, message=FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(dplyr)
library(knitr)

# Generate summary of selected numerical variables for the under 60 group
summary_under_60_data <- summary(under_60_data[, c("age", "avg_glucose_level", "bmi")])
summary_under_60_data

# Convert the summary to a data frame & display it with kable
summary_table_under_60 <- as.data.frame.matrix(summary_under_60_data)
knitr::kable(summary_table_under_60, caption = "Summary of Numerical Variables for Individuals Under 60 Years Old", row.names = FALSE)
```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(dplyr)
library(knitr)

# List of categorical variables to summarize for individuals under 60
variables_to_summarize <- c("stroke", "gender", "ever_married", 
                             "work_type", "Residence_type", 
                             "smoking_status", "hypertension", 
                             "heart_disease")

# Convert binary integer variables to factors in the under_60_data dataset
under_60_data <- under_60_data %>%
  mutate(
    stroke = as.factor(stroke),
    hypertension = as.factor(hypertension),
    heart_disease = as.factor(heart_disease)
  )

# Calculate total count for proportion calculation
total_count_under_60 <- nrow(under_60_data)

# Create summary table for individuals under 60
summary_table_under_60 <- bind_rows(
  lapply(variables_to_summarize, function(var) {
    under_60_data %>%
      group_by(.data[[var]]) %>%
      summarize(
        Count = n(),
        Proportion = n() / total_count_under_60,
        .groups = "drop"
      ) %>%
      rename(Type = .data[[var]]) %>%
      mutate(
        Variable = var,
        Type = as.character(Type),
        Proportion = round(Proportion * 100, 2)  
      )
  })
) %>%
  select(Variable, Type, Count, Proportion) %>%  
  arrange(Variable, Type)                        

# Display the combined table with kable
knitr::kable(summary_table_under_60, caption = "Summary of Categorical Variables for Individuals Under 60 Years Old with Proportions", row.names = FALSE)
```

### Univariate Analysis for individuals below 60

#### Numerical variables for individuals below 60

Same as for the whole group EDA, we visualized all numerical variables in a histogram grouped by stroke occurrence to get an overview of the distribution of the data and their relationship with the target variable.

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(plotly)
library(ggplot2)
library(dplyr)

# Function to create the histogram
create_histogram <- function(data, variable, stroke_variable, binwidth = 5, show_legend = FALSE) {
  # Extract the variable and stroke data
  original_data <- data[[variable]]
  stroke_data <- data[[stroke_variable]]
  
  # Calculate mean and standard deviation for reference lines
  mean_val <- mean(original_data, na.rm = TRUE)
  sd_val <- sd(original_data, na.rm = TRUE)
  mean_line <- mean_val
  sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
  
  # Combine data and stroke status into a data frame
  plot_data <- data.frame(data = original_data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))
  
  # Generate the ggplot stacked histogram with mean and SD lines
  p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
    geom_histogram(binwidth = binwidth, color = "white", position = "stack") +
    labs(title = paste("Distribution of", variable), x = variable, y = "Frequency", fill = "Stroke Status") +
    geom_vline(xintercept = mean_line, color = "blue", linetype = "dashed", linewidth = 1) +
    geom_vline(xintercept = sd_lines[1], color = "red", linetype = "dotted", linewidth = 0.8) +
    geom_vline(xintercept = sd_lines[2], color = "red", linetype = "dotted", linewidth = 0.8) +
    theme_minimal()
  
  # Convert to interactive Plotly plot
  ggplotly(p) %>%
    layout(showlegend = show_legend) # Control legend visibility
}

# Generate histograms for individuals under 60
hist_age <- create_histogram(under_60_data, "age", "stroke", binwidth = 5, show_legend = TRUE)
hist_glucose <- create_histogram(under_60_data, "avg_glucose_level", "stroke", binwidth = 5, show_legend = FALSE)
hist_bmi <- create_histogram(under_60_data, "bmi", "stroke", binwidth = 5, show_legend = FALSE)

# Combine histograms into a grid layout (1 row)
combined_histograms <- subplot(
  hist_age, hist_glucose, hist_bmi,
  nrows = 1, titleX = TRUE, titleY = TRUE
) %>%
  layout(
    title = "Histograms of Numerical Variables by Stroke (Individuals Under 60 Years)",
    showlegend = TRUE  # Ensure unified legend is displayed
  )

# Display the combined histograms
combined_histograms
```


##### Violin plots for individuals below 60 #####

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(plotly)

# Function to create a violin plot
create_violin_plot <- function(data, variable, stroke_variable) {
  # Ensure the stroke variable is a factor
  data[[stroke_variable]] <- as.factor(data[[stroke_variable]])
  
  # Generate the violin plot
  plot <- plot_ly(data, x = ~get(stroke_variable), y = ~get(variable), type = "violin",
                  box = list(visible = TRUE),
                  meanline = list(visible = TRUE),
                  name = variable) %>%  # Add the variable name here
    layout(
      title = paste("Violin Plot of", variable, "by Stroke (Individuals Under 60)"),
      xaxis = list(title = "Stroke"),
      yaxis = list(title = variable)
    )
  
  plot
}

# Generate individual plots for individuals under 60
plot_age <- create_violin_plot(under_60_data, variable = "age", stroke_variable = "stroke")
plot_glucose <- create_violin_plot(under_60_data, variable = "avg_glucose_level", stroke_variable = "stroke")
plot_bmi <- create_violin_plot(under_60_data, variable = "bmi", stroke_variable = "stroke")

# Combine plots into a grid layout (1 row, 3 columns)
combined_plot <- subplot(
  plot_age, plot_glucose, plot_bmi,
  nrows = 1, titleX = TRUE, titleY = TRUE
) %>%
  layout(title = "Violin Plots of Numerical Variables by Stroke (Individuals Under 60 Years)")

# Display the combined plot
combined_plot
```

Based on the summary table for numerical variables and the histogram, we can observe the following descriptive characteristics:

-   `age`: The dataset includes individuals with ages ranging from 0.08 to 59 years, with an average age of 33.03 years. 
-   `avg_glucose_level`: We can observe a right-skewed bimodal distribution with a mean of 100.34. The average glucose levels range from 55.12 to 267.76 mg/dL.
-   `bmi`: The histogram shows a right-skewed distribution with a mean of 28.5. The BMI values range from 10.3 to 97.6.

For completeness we added a violin Plot of the numerical variables with correlation coefficients respective to `stroke` displayed below the plot.

### Categorical variables for individuals below 60
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(plotly)
library(ggplot2)
library(dplyr)

# Updated list of categorical variables for the analysis
variables_to_summarize <- c("ever_married", "work_type", 
                             "smoking_status", "hypertension", 
                             "heart_disease")

# Function to create a bar chart based on the selected variable
create_bar_chart <- function(data, variable) {
  # Create a reactive data frame that filters "Other" for gender
  filtered_data <- data
  if (variable == "gender") {
    filtered_data <- filtered_data %>% filter(gender != "Other")
  }
  
  # Generate the bar plot
  p <- ggplot(filtered_data, aes_string(x = variable, fill = "as.factor(stroke)")) +
    geom_bar(position = "fill") +
    labs(fill = "STROKE", y = "Proportion", title = paste("Proportion of Stroke by", variable, "for under 60")) +
    theme_minimal() +
    scale_fill_manual(values = c("0" = "#1f77b4", "1" = "#ff7f0e")) # Custom colors

  # Convert ggplot to an interactive plotly object
  ggplotly(p)
}

# Generating and displaying individual plots
for (var in variables_to_summarize) {
  bar_plot <- create_bar_chart(under_60_data, var)
  print(bar_plot)
}
```

### Same as for whole dataset, we remove gender and residence type for readability reasons
Now that we completed the EDA of the group aged below 60, let's check for the group aged of 60 and over.

#### Descriptive Statistics for individuals of 60 and over

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(dplyr)
library(knitr)

# Generate summary of selected numerical variables for the over 60 group
summary_over_60_data <- summary(over_60_data[, c("age", "avg_glucose_level", "bmi")])
summary_over_60_data

# Convert the summary to a data frame & display it with kable
summary_table_over_60 <- as.data.frame.matrix(summary_over_60_data)
knitr::kable(summary_table_over_60, caption = "Summary of Numerical Variables for Individuals Over 60 Years Old", row.names = FALSE)
```

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(dplyr)
library(knitr)

# List of categorical variables to summarize for individuals over 60
variables_to_summarize <- c("stroke", "gender", "ever_married", 
                             "work_type", "Residence_type", 
                             "smoking_status", "hypertension", 
                             "heart_disease")

# Convert binary integer variables to factors in the over_60_data dataset
over_60_data <- over_60_data %>%
  mutate(
    stroke = as.factor(stroke),
    hypertension = as.factor(hypertension),
    heart_disease = as.factor(heart_disease)
  )

# Calculate total count for proportion calculation
total_count_over_60 <- nrow(over_60_data)

# Create summary table for individuals over 60
summary_table_over_60 <- bind_rows(
  lapply(variables_to_summarize, function(var) {
    over_60_data %>%
      group_by(.data[[var]]) %>%
      summarize(
        Count = n(),
        Proportion = n() / total_count_over_60,
        .groups = "drop"
      ) %>%
      rename(Type = .data[[var]]) %>%
      mutate(
        Variable = var,
        Type = as.character(Type),
        Proportion = round(Proportion * 100, 2)  
      )
  })
) %>%
  select(Variable, Type, Count, Proportion) %>%  
  arrange(Variable, Type)                        

# Display the combined table with kable
knitr::kable(summary_table_over_60, caption = "Summary of Categorical Variables for Individuals Over 60 Years Old with Proportions", row.names = FALSE)
```
## Univariate Analysis for individuals of 60 and over

### Numerical variables for individuals of 60 and over
```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(plotly)
library(ggplot2)
library(dplyr)

# Function to create the histogram
create_histogram <- function(data, variable, stroke_variable, binwidth = 5, show_legend = FALSE) {
  # Extract the variable and stroke data
  original_data <- data[[variable]]
  stroke_data <- data[[stroke_variable]]
  
  # Calculate mean and standard deviation for reference lines
  mean_val <- mean(original_data, na.rm = TRUE)
  sd_val <- sd(original_data, na.rm = TRUE)
  mean_line <- mean_val
  sd_lines <- c(mean_val - sd_val, mean_val + sd_val)
  
  # Combine data and stroke status into a data frame
  plot_data <- data.frame(data = original_data, stroke = factor(stroke_data, labels = c("No Stroke", "Stroke")))
  
  # Generate the ggplot stacked histogram with mean and SD lines
  p <- ggplot(plot_data, aes(x = data, fill = stroke)) +
    geom_histogram(binwidth = binwidth, color = "white", position = "stack") +
    labs(title = paste("Distribution of", variable), x = variable, y = "Frequency", fill = "Stroke Status") +
    geom_vline(xintercept = mean_line, color = "blue", linetype = "dashed", linewidth = 1) +
    geom_vline(xintercept = sd_lines[1], color = "red", linetype = "dotted", linewidth = 0.8) +
    geom_vline(xintercept = sd_lines[2], color = "red", linetype = "dotted", linewidth = 0.8) +
    theme_minimal()
  
  # Convert to interactive Plotly plot
  ggplotly(p) %>%
    layout(showlegend = show_legend) # Control legend visibility
}

# Generate histograms for individuals over 60
hist_age <- create_histogram(over_60_data, "age", "stroke", binwidth = 5, show_legend = TRUE)
hist_glucose <- create_histogram(over_60_data, "avg_glucose_level", "stroke", binwidth = 5, show_legend = FALSE)
hist_bmi <- create_histogram(over_60_data, "bmi", "stroke", binwidth = 5, show_legend = FALSE)

# Combine histograms into a grid layout (1 row)
combined_histograms <- subplot(
  hist_age, hist_glucose, hist_bmi,
  nrows = 1, titleX = TRUE, titleY = TRUE
) %>%
  layout(
    title = "Histograms of Numerical Variables by Stroke (Individuals Over 60 Years)",
    showlegend = TRUE  # Ensure unified legend is displayed
  )

# Display the combined histograms
combined_histograms
```


####Violin plots for individuals of 60 and over ####

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(plotly)

# Function to create a violin plot
create_violin_plot <- function(data, variable, stroke_variable) {
  # Ensure the stroke variable is a factor
  data[[stroke_variable]] <- as.factor(data[[stroke_variable]])
  
  # Generate the violin plot
  plot <- plot_ly(data, x = ~get(stroke_variable), y = ~get(variable), type = "violin",
                  box = list(visible = TRUE),
                  meanline = list(visible = TRUE),
                  name = variable) %>%  # Add the variable name here
    layout(
      title = paste("Violin Plot of", variable, "by Stroke (Individuals Aged 60 and Over)"),
      xaxis = list(title = "Stroke"),
      yaxis = list(title = variable)
    )
  
  plot
}

# Generate individual plots for individuals aged 60 and over
plot_age <- create_violin_plot(over_60_data, variable = "age", stroke_variable = "stroke")
plot_glucose <- create_violin_plot(over_60_data, variable = "avg_glucose_level", stroke_variable = "stroke")
plot_bmi <- create_violin_plot(over_60_data, variable = "bmi", stroke_variable = "stroke")

# Combine plots into a grid layout (1 row, 3 columns) with titles for each variable
combined_plot <- subplot(
  plot_age %>% layout(title = "Age"),
  plot_glucose %>% layout(title = "Average Glucose Level"),
  plot_bmi %>% layout(title = "BMI"),
  nrows = 1, titleX = TRUE, titleY = TRUE
) %>%
  layout(title = "Violin Plots of Numerical Variables by Stroke (Individuals Aged 60 and Over)")

# Display the combined plot
combined_plot
```

### Categorical variables for individuals of 60 and over

```{r, message = FALSE}
#| code-fold: true
#| code-summary: "Click to show code"
library(plotly)
library(ggplot2)
library(dplyr)

# Updated list of categorical variables for the analysis
variables_to_summarize <- c("ever_married", "hypertension", "heart_disease")

# Function to create a bar chart based on the selected variable
create_bar_chart <- function(data, variable) {
  # Generate the bar plot
  p <- ggplot(data, aes_string(x = variable, fill = "as.factor(stroke)")) +
    geom_bar(position = "fill") +
    labs(fill = "STROKE", y = "Proportion", title = paste("Proportion of Stroke by", variable, "for 60 and over")) +
    theme_minimal() +
    scale_fill_manual(values = c("0" = "#1f77b4", "1" = "#ff7f0e")) # Custom colors

  # Convert ggplot to an interactive plotly object
  ggplotly(p)
}

# Generating and displaying individual plots for individuals over 60
for (var in variables_to_summarize) {
  bar_plot <- create_bar_chart(over_60_data, var)
  print(bar_plot)
}
```

####We remove gender and residence type, we talk about how now the proportion of people that had a stroke that have never been married is higher than those who have (unlike before). The proportion of individuals who have experienced a stroke appears to be equal across the three categories of the smoking status variable, and similarly for the work type variable (See appendix).#####


#### Balancing Stratified Dataset

In our dataset, we have a total of 1,376 individuals aged 60 and over, and 3,734 individuals under 60.

```{r, warning=FALSE}
#|code-fold: true
#|code-summary: "Click to show the code"

low_risk_age_tb <- outlier_stroke_tb %>%
  filter(age < 60)

low_risk_age_tb$stroke <- as.factor(low_risk_age_tb$stroke)

x_data <- low_risk_age_tb[, names(low_risk_age_tb) != "stroke"] 
y_data <- low_risk_age_tb$stroke                             

# Perform upsampling
low_risk_age_tb <- upSample(
  x = x_data,
  y = y_data,
  yname = "stroke" # Column name for the target variable in the upsampled dataset
)

# Step 3: Check the class distribution to confirm balancing
table(low_risk_age_tb$stroke)

# Scaling
low_risk_age_tb[sapply(low_risk_age_tb, is.double)] <- lapply(low_risk_age_tb[sapply(low_risk_age_tb, is.double)], scale)


# save

write.csv(low_risk_age_tb, "../../data/datasets/low_risk_age_tb.csv")

```


```{r, warning=FALSE}
#|code-fold: true
#|code-summary: "Click to show the code"

high_risk_age_tb <- outlier_stroke_tb %>%
  filter(age >= 60)

high_risk_age_tb$stroke <- as.factor(high_risk_age_tb$stroke)

x_data <- high_risk_age_tb[, names(high_risk_age_tb) != "stroke"] 
y_data <- high_risk_age_tb$stroke                             

# Perform upsampling
high_risk_age_tb <- upSample(
  x = x_data,
  y = y_data,
  yname = "stroke" # Column name for the target variable in the upsampled dataset
)

# Step 3: Check the class distribution to confirm balancing
table(high_risk_age_tb$stroke)

# Scaling
high_risk_age_tb[sapply(high_risk_age_tb, is.double)] <- lapply(high_risk_age_tb[sapply(high_risk_age_tb, is.double)], scale)

# save

write.csv(high_risk_age_tb, "../../data/datasets/high_risk_age_tb.csv")

```
