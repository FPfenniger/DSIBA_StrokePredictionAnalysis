<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Final Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_final_analysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="_final_analysis_files/libs/quarto-html/quarto.js"></script>
<script src="_final_analysis_files/libs/quarto-html/popper.min.js"></script>
<script src="_final_analysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_final_analysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="_final_analysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_final_analysis_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_final_analysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_final_analysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_final_analysis_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Analysis</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="final-analysis" class="level1">
<h1>Final Analysis</h1>
<p>In this final section, we will present the results of our analysis and discuss the implications of our findings. We start with a results section, where we discuss the performance of the models we trained. We then move on to a conclusions section, where we discuss the implications of our findings and how they relate to our research questions. Finally, we present some final thoughts on the project.</p>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>In this section we discuss and summarize the performance of each model and what potential implications they have for our research questions, before answering them directly in the next section.</p>
<section id="naive-model" class="level3">
<h3 class="anchored" data-anchor-id="naive-model">Naive Model</h3>
<p>Our naive model, which simply predicted the most common outcome (No stroke), performed quite badly. With a recall of zero, this model recognizes no Strokes and cannot predict stroke occurrence. This is not surprising, as the data is imbalanced and the model is not trained to recognize the minority class. No insights can be gathered from this model and in a real-world setting, it would be useless.</p>
</section>
<section id="balanced-model" class="level3">
<h3 class="anchored" data-anchor-id="balanced-model">Balanced Model</h3>
<p>The balanced model performed much better than the naive model. Particularly the high recall, makes us confident that this model could be useful in a real-world setting.</p>
<p>The odds ratio table provide us with interesting findings regarding the risk factors. Our results align with prior studies that highlight hypertension, heart disease, smoking, and age as key risk factors for adverse health outcomes. The significant effect of smoking, even for former smokers, underscores the long-lasting impact of tobacco exposure. The protective association of employment types such as government jobs or self-employment may reflect socioeconomic or lifestyle-related factors, which could be explored further in future studies. Interestingly, women seem to be at a higher risk at least in this model. This is probably simply due to the fact that women are overrepresented in the balanced dataset (58.46% of the population is female).</p>
<p>The model’s high Recall and AUC values suggest its potential for use in identifying high-risk individuals effectively. However, the moderate level of false positives indicates a need for further refinement, potentially by incorporating additional predictors or using ensemble methods for comparison.</p>
<p>Overall, the logistic regression model provides valuable predictive insights and identifies clear risk factors, making it a useful tool for targeted intervention and further analysis.</p>
</section>
<section id="low-risk-age-model" class="level3">
<h3 class="anchored" data-anchor-id="low-risk-age-model">Low-Risk Age Model</h3>
<p>The stratified logistic regression model for the low-risk age group achieved strong performance, with an AUC of 0.844 and high Recall (0.842), highlighting its ability to identify positive outcomes with minimal false negatives. Hypertension, smoking status, and age emerged as the most significant predictors, underscoring their critical role even in a low-risk demographic. <code>heart_disease</code> does not seem to be a significant predictor in this model, which is interesting. This could be due to the fact that the low-risk age group is less likely to experience heart disease.</p>
<p>The protective effects observed for employment type and marital status provide additional insights that warrant further investigation into their underlying mechanisms. While the model produced some false positives, the balance of high Recall and overall accuracy makes it a reliable tool for identifying at-risk individuals in targeted screening efforts.</p>
</section>
<section id="high-risk-age-model" class="level3">
<h3 class="anchored" data-anchor-id="high-risk-age-model">High-Risk Age Model</h3>
<p>The logistic regression model for the high-risk age group demonstrated moderate performance, with an AUC of 0.665 and an Accuracy of 59.8%, reflecting its limitations in sensitivity and overall predictive power. While the model successfully identified key risk factors, such as Heart Disease, Hypertension, and Urban Residence, it struggled to correctly classify a substantial portion of positive cases, as evidenced by the lower Recall of 51.0%.</p>
<p>Notably, protective effects were observed for being self-employed and ever married, suggesting that socioeconomic and social factors may mitigate risk within this group. The negative association of BMI warrants further investigation to clarify its role in the high-risk population.</p>
<p>The poor performance of the high-risk age model can primarily be attributed to the complex, non-linear relationships and high heterogeneity within this group. In older populations, health outcomes are often influenced by intricate interactions between risk factors, such as comorbidities, lifestyle, and physiological thresholds, which a linear logistic regression fails to capture. Additionally, the high variability in health profiles and behaviors within this age group introduces substantial heterogeneity, making it difficult for the model to identify consistent patterns. These factors collectively limit the model’s ability to generalize, leading to reduced sensitivity, lower discriminative power, and overall weaker performance</p>
</section>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>The comparative evaluation of the stratified logistic regression models across <strong>low-risk</strong>, <strong>high-risk</strong>, and the <strong>balanced group</strong> provided valuable insights into model performance, predictor significance, and the challenges of predicting risk across different populations.</p>
<section id="model-performance-overview" class="level4">
<h4 class="anchored" data-anchor-id="model-performance-overview">Model Performance Overview</h4>
<ol type="1">
<li><p><strong>Low-Risk Age Group Models</strong><br>
The models for the low-risk age groups demonstrated <strong>strong performance</strong>, with high sensitivity (<strong>Recall &gt; 84%</strong>), precision, and balanced overall accuracy (<strong>&gt;78%</strong>). The discriminative ability was also excellent, with <strong>AUC values &gt; 0.84</strong>. These models effectively identified key risk factors while minimizing false negatives, making them reliable for early risk screening in younger, healthier populations.</p></li>
<li><p><strong>High-Risk Age Group Model</strong><br>
The high-risk age group model exhibited <strong>lower performance</strong>, with a <strong>Recall of 51%</strong>, overall accuracy of <strong>59.8%</strong>, and an <strong>AUC of 0.665</strong>. The model struggled to correctly identify positive cases, likely due to the <strong>complex, non-linear relationships</strong> and significant <strong>heterogeneity</strong> inherent to older populations. The oversimplification of these relationships by linear logistic regression reduced its ability to generalize patterns effectively.</p></li>
<li><p><strong>Balanced (Overall) Model</strong><br>
The overall model, which combined all age groups, achieved a moderate balance between the two extremes. With an <strong>Accuracy of 77.9%</strong>, an <strong>F1 score of 0.79</strong>, and an <strong>AUC of 0.839</strong>, the balanced model demonstrated reliable performance across both low- and high-risk individuals. While it does not perform as well as the stratified low-risk model, it provides a reasonable compromise for applications where age stratification is not feasible.</p></li>
</ol>
</section>
<section id="insights-on-key-predictors" class="level4">
<h4 class="anchored" data-anchor-id="insights-on-key-predictors">Insights on Key Predictors</h4>
<p>Across all models, several predictors consistently emerged as significant, while others revealed varying effects depending on the age group:</p>
<ol type="1">
<li><p>Hypertension and Heart Disease These were the most prominent predictors across all groups, particularly in older individuals. In the high-risk model, hypertension increased the odds of the outcome by approximately 1.3x, while heart disease had an odds ratio of <strong>1.44</strong>. This aligns with their known role as primary health risk factors.</p></li>
<li><p>Smoking Status</p>
<ul>
<li>In the low-risk model, both current and former smoking significantly increased risk, with odds ratios exceeding 1.4, indicating a strong association. This aligns well with research, that suggest that for younger individuals life style choices are more important. Hemorrhagic strokes are relatively more common, often linked to trauma, aneurysms, or substance use.</li>
<li>In the high-risk group, smoking effects diminished, likely due to the dominance of other comorbidities, such as hypertension and heart disease, in older individuals.Conversely, ischemic strokes are more common in older individuals, often due to atherosclerosis, hypertension, or heart disease.</li>
</ul></li>
<li><p>Age and Average Glucose Level</p>
<ul>
<li>Age emerged as an important gradual risk factor in low-risk model and the balanced model as well.</li>
<li>Average glucose level had a consistently small but significant positive association across all models, reinforcing the role of metabolic health.</li>
</ul></li>
<li><p>Protective Predictors Predictors such as being ever marriedand working in <strong>self-employed</strong> or <strong>government jobs</strong> consistently demonstrated a protective effect. For instance:</p>
<ul>
<li>Being <strong>ever married</strong> reduced risk significantly in the high-risk group (<strong>OR = 0.49, p &lt; 0.001</strong>).<br>
</li>
<li>Self-employed individuals also exhibited lower odds of the outcome (<strong>OR ~ 0.70</strong>).</li>
</ul></li>
</ol>
<p>These protective effects may reflect unmeasured social, economic, or lifestyle factors that warrant further exploration.</p>
<ol start="5" type="1">
<li>BMI BMI demonstrated contradictory effects across models:
<ul>
<li>In low-risk groups, BMI had a slight positive association.<br>
</li>
<li>In the high-risk model, BMI showed a <strong>protective effect</strong> (<strong>OR = 0.96</strong>), possibly due to non-linear relationships where low BMI could indicate frailty or underlying illness in older individuals.</li>
</ul></li>
</ol>
</section>
<section id="key-challenges" class="level4">
<h4 class="anchored" data-anchor-id="key-challenges">Key Challenges</h4>
<ol type="1">
<li><p>Complex, Non-Linear Relationships The high-risk model underperformed due to its inability to capture the <strong>non-linear and threshold effects</strong> that are prevalent in older populations, such as interactions between hypertension, heart disease, and glucose levels.</p></li>
<li><p>Heterogeneity in the High-Risk Group<br>
The high variability in health profiles and comorbidities within the high-risk group made it difficult for the model to identify consistent patterns, leading to lower Recall and discriminative ability.</p></li>
<li><p>Balanced Model Trade-offs While the balanced model performed reasonably well across both age groups, it did not capture age-specific nuances as effectively as the stratified low-risk model. This highlights the importance of tailoring models to subgroups to optimize predictive performance.</p></li>
<li><p>External Validity, Generalizability &amp; Missing Health Metrics We suspect that important health metrics such as cholesterol levels, physical activity, and dietary habits, or alcohol consumption could further improve model performance and provide more comprehensive risk assessments. Future analysis should consider incorporating these variables to enhance predictive power. Our findings may be significantly limited in external validity because these metrics are missing</p></li>
</ol>
</section>
<section id="research-questions" class="level3">
<h3 class="anchored" data-anchor-id="research-questions">Research Questions</h3>
<p>To end our predictive model analysis, we will now answer our research questions based on the insights gained from our models:</p>
<ol type="1">
<li>What are the most significant risk factors associated with stroke?
<ul>
<li>Hypertension, Heart Disease, Smoking, Age, and Average Glucose Level emerged as the most significant risk factors across all models. These factors consistently increased the odds of stroke occurrence, highlighting their critical role in predicting adverse health outcomes.</li>
</ul></li>
<li>How accurately can a logistic regression model predict the occurrence of having a stroke?
<ul>
<li>The logistic regression models demonstrated varying levels of predictive accuracy, with the low-risk age group model performing the best (AUC &gt; 0.84). The balanced model also achieved a reasonable balance between sensitivity and specificity, with an AUC of 0.839. However, the high-risk age group model exhibited lower performance due to the complexity and heterogeneity of older populations. Overall, we are content with the predictive power of our models, however with further investigation and refinement such as regularization or ensemble methods, we could potentially improve the models even more, particularly for the high-risk age group.</li>
</ul></li>
</ol>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>